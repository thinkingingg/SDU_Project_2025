SM2的软件实现优化
==================

## 一、任务要求

1. 考虑到SM2用C 语言来做比较复杂，大家看可以考虑用python来做 sm2的 基础实现以及各种算法的改进尝试

2. 20250713-wen-sm2-public.pdf 中提到的关于签名算法的误用 分别基于做poc验证，给出推导文档以及验证代码

3. 伪造中本聪的数字签名

本实验包含四个主要任务：

1. **SM2 基础算法实现**：实现 SM2 椭圆曲线数字签名算法，包括密钥生成、签名与验签。

2. **性能优化实现**：在基础实现上进行优化，主要通过点乘优化（窗口法）提升签名速度，并进行性能对比。

3. **随机数 k 泄露攻击验证**：模拟随机数 k 泄露的攻击场景，通过泄露的 k 值恢复私钥。

4. **数字签名伪造演示（中本聪实验）**：演示基于脆弱验证过程的签名伪造，包括构造可通过验证的伪造签名。
   
   

## 二、SM2 基础算法实现

### 1. 椭圆曲线定义

SM2 基于素域 上的椭圆曲线：

曲线参数为：

```python
p = 0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF 
a = 0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC 
b = 0x28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93 
Gx = 0x32C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7 
Gy = 0xBC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0 
n = 0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123
```

### 2. 密钥生成

1. **私钥** $d \in [1, n-1]$随机选择。

2. **公钥** $P = d \cdot G$通过椭圆曲线点乘计算。

数学表示：

$$
P = dG
$$



### 3. 签名算法

给定消息M：

1. 计算消息哈希$e = \text{SHA-256}(M)$：

2. 随机选择$k \in [1, n-1]$

3. 计算点$kG = (x_1, y_1)$

4. 计算：
   
   $$
   r = (e + x_1) \bmod n
   $$

若$r=0$ 或 $r+k=n$，重新选择$k$

5. 计算：
   
   $$
   s = ((1+d)^{-1} \cdot (k - r \cdot d)) \bmod n
   $$

若$s=0$，重新选择 $k$

6. 输出签名$(r, s)$

### 4. 验签算法

1. 计算消息哈希：
   
   $$
   e = \text{SHA-256}(M)
   $$

2. 计算：
   
   $$
   t = (r+s) \bmod n
   $$

若t=0，验签失败

3. 计算：
   
   $$
   (x_1, y_1) = s \cdot G + t \cdot P
   $$

4. 验证：
   
   $$
   R = (e + x_1) \bmod n
   $$

若 R=r ，签名有效；否则无效

## 三、点乘优化

### 1. 优化方法

基础算法的点乘采用重复加法和翻倍，时间复杂度较高。优化方法采用 **窗口法**：

1. 将私钥二进制分为窗口长度

2. 预计算点：

3. 对每一窗口的二进制值直接查表加点，减少重复加法次数

### 2. 实验结果

实验中对比原始签名和优化签名耗时：

| 方法  | 签名耗时 (s) | 性能提升  |
| --- | -------- | ----- |
| 原始  | 0.034457 | 1x    |
| 优化  | 0.033695 | 1.02x |

## 四、随机数 k 泄露攻击

### 1. 攻击原理

如果同一私钥签名时泄露了随机数 $k$，攻击者可通过签名 $(r, s)$ 恢复私钥：

### 2. 实验验证

1. 获取签名 $(r, s)$ 和随机数 $k$

2. 使用公式计算 $d\_recovered$

3. 验证是否与原私钥一致

### 3. 实验结果

```python
恢复的私钥: 0x79373b9b7b878e9a90cbbabd8be0c21ed28743e0e038a7a471c975afaf202675 
恢复私钥是否正确: True
```

## 五、数字签名伪造演示（中本聪实验）

### 1. 伪造原理

攻击者无需私钥，通过选择随机数 $r', s'$ 构造伪造签名，并计算对应伪造哈希 $e'$：

$$
t = (r'+s') \bmod n
$$

$$
(x_1, y_1) = s' \cdot G + t \cdot P
$$

$$
e' = (r' - x_1) \bmod n
$$

在脆弱验证中，使用伪造哈希进行验签，签名可通过验证；在安全验证中，由于消息哈希不匹配，伪造签名失败。

### 2. 实验结果

    伪造消息: 中本聪伪造签名实验消息
    伪造签名: (61887816172228603894805334836329862477343981186579523838793181747320671027041,
              94237953181075133658844086340938457325485416360226031840159458637918039770532)
    脆弱验证结果 (应通过): True
    安全验证结果 (应失败): False 

## 六、实现思路

- **模块化设计**：基础算法 (`sm2_basic.py`) 与实验模块分离，便于复用。

- **优化点乘**：窗口法减少重复加法次数，提高签名速度。

- **攻击模拟**：
  
  * 随机数 k 泄露攻击验证私钥恢复方法
  
  * 数字签名伪造演示验证脆弱验签风险

- **安全提示**：真实系统应确保：
  
  * 随机数 k 安全生成且不泄露
  
  * 验签过程中独立计算消息哈希，避免外部控制
  
  * 使用防伪造的签名验证机制 

## 七、总结

1. SM2 数字签名算法可实现可靠的消息认证。

2. 窗口法点乘可提升性能，但提升幅度有限。

3. 随机数 k 泄露可导致私钥恢复，验证了 SM2 的安全假设依赖 k 安全。

4. 脆弱验证可被伪造签名绕过，强调了验签实现中的安全注意事项。


